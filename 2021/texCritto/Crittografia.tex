\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}

%SetFonts
\graphicspath{ {./images/} }
%SetFonts

\usepackage{caption}
\captionsetup[figure]{labelformat=empty}%
\usepackage{subcaption} 

\title{Crittografia}
%\author{The Author}
%\date{}							% Activate to display a given date or no date
\usepackage{float}
\begin{document}
\maketitle
%\section{}
%\subsection{}
Mercoledi: 13 - 14.30, 
Venerdì: 13 - 14.30\\
Modalità d'esame: orale - 16233\\
Programma:
\begin{itemize}
\item Accenni storici
\item Cifrario simmetrico con una chiave
\item Cifrario asimmetrico con due chiavi, una per aprire una per chiudere
\item Funzioni hash
\end{itemize}

In un cifrario simmetrico, la chiave di enconding è uguale alla chiave di decoding; nel cifrario asimmetrico le chiavi di enconding e decoding sono differenti.\\
Dato un mittente A, ed un ricevente B, il mittente A cifra il plain text in cypher text utilizzando le chiavi di enconding. Il cypher text viene trasmesso nel canale di comunicazione, che verrà poi passerà nel processo di decoding da parte di B, per ricavare nuovamente il plain text iniziale. \\
Scenari di attacco:\\
1) Cyphertext only \\ 
2) Known plaintext \\
3) Chosen plaintext \\
4) Chosen cyphertext \\\\
- I cifrari simmetrico vengono utilizzate per cifrari grosse quantità di dati (eg. testo, \emph{des e aes})\\
- I cifrari asimmetrici vengono utilizzati per cifrare piccole quantità di dati (eg. pw, \emph{rsa, elgamal})\\
- Le tecniche steganografiche sono tecniche di offuscazione del messaggio\\\\
Principio di Kerkhoff: un cifrario è forte sse l'attaccante conosce tutto tranne che la chiave. \emph{Brutalmente: se un cifrario rimane pubblico per 30 anni, ma non viene bucato, vuol dire che è resiliente.}\\\\
4 proprietà delle funzioni crittografiche:\\
- Confidenzialità: ottenuta attraverso l'operazione di cifratura prima della spedizione\\
- Integrità dei dati: applicando una funzione crittografica, se il risultato è medesimo nel caso del mittente e del destinatario la cifratura è considerata integro (hashing functions)\\
- Autenticazione: garantire che solo gli interessati siano in grado di accedere alle informazioni\\
- Non ripudio:  l'autore di una dichiarazione non potrà negare la paternità e la validità della dichiarazione stessa\\\\
Cifrari storici:\\\\
\textbf{Cifrario di Cesare} \\
Basato sulla traslazione delle lettere, dato un k trasliamo l'alfabeto di k valori\\\\
\textbf{Quadrato di Polibio} \\
Viene creato una matrice, si inseriscono le lettere all'interno della matrice e per ogni corrispondenza si prende la coppia colonna riga. Il cyphertext è grande 2x il plaintext. Il problema di questo cifrario è che ha punti fissi. \\
Un approccio migliore è passare da espressioni \(y = x + k \) a \(y = \alpha x + \beta \) con \(\alpha \neq 0   , \beta \neq 0 \)\\Per ricavare un valore dobbiamo fare \((y-\beta)/\alpha = x\). \\E' inoltre importante che MCD($\alpha, 26)$ = 1 ovvero che $\alpha$ sia invertibile, e che $\alpha$ e 26 siano \emph{coprimi}; il numero totale di chiavi possibili è $12 * 26$.\\\\
Come attacchiamo i crittosistemi affini? Andiamo ad analizzare il le frequenze. \\Dato il teorema di Kerkhoff l'attaccante conosce tutte le informazioni riguardo il cifrario, ma non la chiave.In italiano le lettere che compaiono di più sono E (che compare in media 11,79 \%), la A (11,74\%), la I (11,28 \%) etc.\\ Più il testo è lungo, più possiamo essere certi della corrispondenza (maggiore il campione, migliore l'approssimazione). Il problema del cifrario affine è quindi che data una lettera, la corrispondenza cifrata è sempre la stessa.\\\\
\textbf{Quadrato di Vigenère}
\begin{figure} [H]
\begin{center}
\includegraphics[scale=0.4]{vig}
\caption{codifica della lettera R con chiave V}
\end{center}
\end{figure}
Viene introdotta una chiave (parola), concordata tra mittente e destinatario. La chiave è ripetuta \emph{n} volte fino a ricavare una corrispondenza 1-1 con il messaggio da cifrare. In questo modo le stesse lettere hanno potenzialmente più corrispondenze. Per ricavare le singole lettere andiamo a ricavare la corrispondenza con colonna \(Cyphertext_i = (Plaintext_i, Chiave_i)\)
\begin{center}
\includegraphics[scale=0.7]{chiave}
\end{center}
Come attacchiamo questo cifrario? Il metodo più famoso è il metodo di Kasiski\\
Attraverso \emph{l'analisi di Kasiski} possiamo sfruttare il fatto che alcune parole, per probabilità, vengono cifrate con le stesse lettere. Questo ci permette di trovare gruppi ripetuti nel \emph{cyphertext}.
\begin{center}
\includegraphics[scale=0.7]{freq}
\end{center}
Una volta identificati questi gruppetti, li raccogliamo e possiamo essere certi che questi sottoinsieme saranno un divisore della chiave. Possiamo quindi effettuare un'analisi di frequenza su queste, più lunga il testo, migliore sarà la precisione dell'analisi di frequenza.\\\\
Una variante è il cifrario di Cardano, in cui la chiave è inserita prima del crittotesto, tecnica molto vulnerabile in quanto è l'attaccante deve solo indovinare la lunghezza.\\\\
\textbf{Playfair cipher}
Il cifrario è basato su una matrice 5x5 (essendo l'alfabeto di 26, una lettera ha una corrispondenza con un'altra, solitamente i con j) in cui vengono inserite le lettere. La chiave è scelta, può essere una parola. Le lettere sono inserite saltando i doppioni, mettendo in testa la chiave.\\
\begin{center}
\includegraphics[scale=0.5]{playfair}
\end{center}
Il cyphertext è creato a coppia di lettere, si forma un rettangolo/quadrato utilizzando i vertici opposti delle due lettere scelte. I vertici opposti rappresentano le lettere cifrate.
\begin{figure} [H]
\begin{center}
\includegraphics[scale=0.5]{playfair2}
\caption{I vertici opposti del rettangolo delle lettere HI sono BM, la codifica è BM}
\end{center}
\end{figure}
\noindent \textbf{Hill cipher}\\
Viene definita una matrice \emph{k} di dimensione \emph{n * n}, le parole vengono cifrate a coppie di n (matrice 2 x 2, cifrate 2 alla volta, matrice 3 x 3, cifrate 3 alla volta).\\
Un esempio può essere quella di prendere 2 lettere alla volta, codificate in numero, valore che è poi utilizzato per fare la moltiplicazione riga per colonna, il valore è passato a mod(26) per ricavare una lettera. Per decodificare facciamo la moltiplicazione per l'inverso della matrice chiave.\\
Non tutte le matrici chiavi sono ammissibili, la matrice deve esser invertibile per permettere il decifraggio da parte del destinatario. In particolare \(MCD(\Delta, 26) = 1\).\\\\
\textbf{ADFGX cipher}
Utilizzata dai generali tedeschi durante la prima guerra mondiale, viene creata una matrice 5 x 5 in cui vengono inserite le lettere arbitrariamente.
\begin{figure}[H]
\begin{subfigure}[h]{0.4\linewidth}
\includegraphics[width=\linewidth]{adfgx}
\end{subfigure}
\hfill
\begin{subfigure}[h]{0.6\linewidth}
\includegraphics[width=\linewidth]{word}
\end{subfigure}%
\end{figure}
Per ricavare il crittotesto prendiamo le coppie degli indici (riga, colonna), ogni lettera quindi è data da una coppia di indici. \\Viene poi riordinato il crittotesto secondo una chiave di lunghezza k. Il crittotesto viene suddiviso in righe di k lunghezza. Una volta messe in pila di lunghezza k, le colonne vengono riordinate secondo l'ordine alfabetico delle lettere chiave.
\begin{figure}[H]
\begin{subfigure}[h]{0.2\linewidth}
\includegraphics[width=\linewidth]{pre}
\end{subfigure}
\hfill
\begin{subfigure}[h]{0.5\linewidth}
\includegraphics[width=\linewidth]{adfgx2}
\caption*{La codifica di CARGO}
\end{subfigure}
\hfill
\begin{subfigure}[h]{0.2\linewidth}
\includegraphics[width=\linewidth]{post}
\end{subfigure}%
\end{figure}
Con questo abbiamo finito con i cifrari storici.\\\\
\section*{NIST / NBS}
Il NIST è un'associazione governativa americata che si occupa di emettere bandi per richiedere la creazione di cifrari per il pubblico. In questo momento i bandi aperti sono: "Post-quantum competition" del 2018 ed il "Lightweight cryptography" per sistemi leggeri.\\
Nel 1970 manda un bando per creare un cifrario simmetrico utile alle grandi aziende americane per cifrare i dati sicuri, in particolare viene sviluppato DES, un cifrario simmetrico.
\section*{DES}
E' un cifrario a 16 round, basato su blocchi di 64, dotato di \emph{64 - 8 (bit di controllo) = 56} bit di chiave che produce un ciphertext di lunghezza 64. Un attacco di brute-forcing svolge al massimo $2^{56}$ tentativi, che già nel 1970 porta molti ad obbiettare.\\
Il plaintext è permutato per 16 volte, l'inverso della permutazione è poi applicato sul plaintext permutato.
\begin{figure}[H]
\begin{subfigure}[h]{0.4\linewidth}
\includegraphics[width=\linewidth]{DES}
\caption*{F è la funzione di Feistel}
\end{subfigure}
\hfill
\begin{subfigure}[h]{0.4\linewidth}
\includegraphics[width=\linewidth]{DES2}
\end{subfigure}%
\end{figure}
\section*{Feistel function}
\emph{Ma dove entra in gioco la chiave?} La chiave è fornita alla funzione di Feistel, è generata per ogni dato round di cifratura.\\\\
\emph{La funzione Feistel}\\
Quando parliamo di funzioni di Feistel parliamo di funzioni la cui sicurezza è acquisita effettuando \emph{n round} di permutazioni
\begin{center}
\includegraphics[scale= 0.4]{feistel}
\end{center}
La funzione \emph{E} è rappresenta permutazione di espansione, che aggiunge 8 bit ai 32 forniti in precedenza. Questi 48 bit 
sono utilizzati per effettuare uno XOR con \emph{J} (la chiave del round), che mi permette di ricavare 8 blocchi.
Questi 8 blocchi (formati da 6 bit ciascuno) sono permutati nuovamente (all'interno di $S_k$).
Le funzioni $S_k$ eseguono \emph{un'operazione di compressione}: prendono in bit 6 bit ciascuno, ma restituiscono 4 bit, portando l'output a 32 bit. Questi 32 bit rappresentano l'output.
\section*{S-Box}
La S-Box è un componente di compressione, $S_k$ è formato da una matrice $(4 * 16)$ sulla quale sono inseriti una permutazione dei valori tra 1 a 16 (fissa).
\begin{center}
\includegraphics[scale= 0.7]{sbox}\\
\emph{un esempio di S-boxes}
\end{center}
Dato una sequenza di input di bit di lunghezza 6 (l'input di ogni s-box), il primo ed l'ultimo valore sono utilizzati per indicizzare la riga, ed i 4 valori interni indicizzano la colonna.
\begin{center}
\includegraphics[scale= 0.8]{sbox1}\\
\emph{Si prende la terza e la sesta perché il binario 00 è la prima colonna, noi contiamo da 0}
\end{center}
Il valore ricavato incrociando riga e colonna codificato in binario rappresenta l'output della S-Box.
Questo è possibile perché nella matrice vi sono solo valori tra 0 e 15, che sono codificabili in binario su 4 valori.
\begin{center}
\includegraphics[scale= 0.8]{sbox2}\\
\emph{il valore di output di questa S-box sarà $0110_2$ = 6$_{(10)}$}
\end{center}
\section*{La chiave $K_i$}
\begin{center}
\includegraphics[scale= 0.6]{k1}
\end{center}
La chiave $K_i$ è formata da 64 bit, dalla quale vengono rimossi 8 bit di parità. Sui bit rimanenti è effettuata una permutazione. I 56 bit dopo la permutazione sono suddivisi in 2 blocchi da 28, chiamati rispettivamente $C_0$ e $D_0$. $C_0$ e $D_0$ sono shiftati a sinistra, a seconda del round.\\
$C_i$ = LS($C_{i-1}$)\\
$D_i$ = LS($D_{i-1}$)\\
Il valori shiftati vengono utilizzati come input per una permutazione/contrazione, passando da 56 a 48. L'output di questa permucontrazione rappresenta la chiave, e gli input della prossima $C_i$  e $D_i$.\\
\begin{center}
\includegraphics[scale= 0.5]{des3}\\
\emph{Overview di DES}
\end{center}
Vi sono dei vincoli riguardo a DES, per esempio:\\
E' importante che dato un S-Box, l'output di tale S-Box non possa in qualsiasi modo approssimabile.
\section*{S-DES | Simplified DES}
I dati:\\
\(plaintext = 12 bits \)\\
\(L_i = 6 bits\)\\
\(R_i = 6 bits\)\\
\(k = 9 bits\)\\
Il numero di round è diminuito, in particolare 3 (II, III, IV), tratteremo quindi:\\ \(L_1, R_1  \rightarrow L_2, R_2 = I° $ $  round\)\\ \(L_2, R_2  \rightarrow L_3, R_3 = II°  $ $round\)\\ \(L_3, R_3  \rightarrow L_4, R_4 = III° $ $ round\). \\\\
\emph{La funzione di Feistel semplificata:}\\
\(R_{(i-1)}\) (6 bits) è passato in espansione (8 bits), e fatta passata in XOR con la chiave (8 bits) (che perde un bit), per poi essere inserita come input (di 4 bits) in 2 S-Box di compressione (matrici 2 * 8).\\
L'output delle S-boxes sono di 3 bits ciascuna, il risultato è \(f(R_{i-1}, k_i\)).\\\\
\emph{La funzione di espansione E(x):}\\
La funzione di espansione ripete dei bit dell'input. In particolare dato un input:\begin{center}
(1-2-3-4-5-6) (6 bits), l'output sarà (1-2-4-3-4-3-5-6) (8 bits) \\in cui k rappresenta la posizione \(k_i\)\\
\end{center}
\emph{Le S-Box semplificate sono:}
\begin{center}
\includegraphics[scale= 0.5]{ssbox}\\
\end{center}
Per ricavare il valore di output è ricavato prendendo: il 1° bit per la riga, e gli altri 3 per la colonna\\
\emph{La compressione della chiave:}\\
La chiave è ricavata copiando la chiave a partire dalla posizione 2, ricopiando dall'inizio quando necessario.\\
\(k = 001001101\)\\
\(k_2 = 010011010\)\\
Il plaintext iniziale è: \(L_1R_1 = 000111-011011\) \\\\\

Il secondo plaintext è: \(L_1R_1 = 101110-011011\)\\
Qual'è \(L_4R_4?\)

L'operazione di crittoanalisi è eseguibile solo se il numero di round è basso (in particolare 3). Se i round sono 4, siamo sicuri che in mezzo c'è almeno un round di crittografia, se siamo a livello 5 sappiamo che sono almeno 2, e così via. L'attacco non è eseguibile deterministicamente, ma probabilisticamente.
\\\\
\emph{Le modalità di cifratura ECB, CBC, CFB, OFB, CTR}\\
Sono le modalità di utilizzo dei cifrari a blocchi, applicabili su qualsiasi cifrario a blocchi:
\begin{itemize}
\item ECB, o \emph{"electronic codebook mode"}:\\
ECB è applicato dividendo il plaintext P in blocchi di equa grandezza, che vengono poi codificati in cyphertext attraverso una cifrario a scelta. La dimensione del blocco è dipendente dal cifrario scelto\\
ECB è ideale quando la quantità di dati da codificare è bassa, se per esempio si vuole traasmettere una chiave DES, ECB è ideale.\\\\
Dato: \\$P = [p_1, ..., p_n]$ l'insieme delle porzioni di grandezza n\\
$C = [c_1, ..., c_n]$ l'insieme dei ciphertext di grandezza n\\
\emph{attraverso la funzione} $f(P_i; DES) = C_i$ possiamo codificare il plaintext in ciphertext 
Per ricavare il plaintext utilizziamo la funzione di decryption su ogni blocco di di ciphertext.
\begin{center}
\includegraphics[scale= 0.7]{ecb}\\
\end{center}
Il problema con ECB è che se più blocchi di plaintext sono uguali, il ciphertext prodotto è uguale. Questo permette su messaggi molto lunghi di essere attaccati attraverso una crittoanalisi di frequenza
\item CBC, o \emph{"cipher block chaining mode"}:\\
Per mitigare le falle di sicurezza di ECB, vogliamo introdurre un meccanismo per produrre ciphertext differenti per plaintext diversi. Con CBC introduciamo un round di XOR con una chiave IV (Initialization vector)(pubblica o privata) prima della fase di encryption, per offuscare ulteriormente la procedura. IV è sostituito dal ciphertext del round $P_i-1$ dalla fase 2 in poi.
\begin{center}
\includegraphics[scale= 0.7]{cbc}\\
\end{center}
Introduciamo una chiave \emph{IV} da applicare in XOR con la prima fase di encryption. Dalla seconda fase in poi l'IV è sostituito con il ciphertext del round $P_i-1$.
\end{itemize}
Il problema con queste modalità è che l'operazione di cifratura avviene su singoli blocchi, piuttosto che su singoli caratteri. Sarebbe comodo poter trasmettere singoli blocchi cifrati alla volta
\begin{itemize}
\item CFB, o \emph{"cipher feedback mode"}:\\
In questo schema di encryption, il vettore di inizializzazione è encryptato con la chiave $k$. $n$ bits dell'output sono utilizzati come input per un'operazione di XOR con il plaintext. L'output è inserito in coda al vettore di inizializzazione prossimo, shiftando l'IV precedente.
\begin{center}
\includegraphics[scale= 0.7]{cfb}\\
\emph{da notare che l'output di encrypt sono 64 bit. \\si prende il primo blocco e quindi un char (8bits)}
\end{center}
In questa modalità la grandezza dei blocchi del plaintext è $s$ (di Select s-bits). \\Se $s = 1 char (8 bits)$, i blocchi del plaintext sono grandi $s$. \\
Il problema con questa modalità è che se compare un errore di trasmissione, esso si propaga, fintanto che il blocco corrotto venga espulso dall'IV.
\item OFB, o \emph{"output feedback mode"}:\\
Questo schema di encryption è molto simile a CFB, ma che risolve il problema di propagazione di errore di trasmissione. Il feedback, che in CFB proveniva dopo allo XOR con il plaintext, viene piuttosto estratto in locale, prima dello XOR.
\begin{center}
\includegraphics[scale= 0.7]{ofb}\\
\end{center}
Il problema con questa modalità è che le operazioni avvengono necessariamente sequenzialmente, piuttosto che in parallelo. 
\item CTR, o \emph{"counter mode"}:\\
Viene introdotto un counter che ha grandezza uguale al plaintext (che tuttavia deve essere necessariamente diverso rispetto ad ogni plaintext che si vuole encryptare). Le due parti devono concordarsi sul valore del counter iniziale, ma siccome il valore del counter è deterministico ed indipendente l'uno dall'altro, possiamo parallelizzare le operazioni di encryption.
\begin{center}
\includegraphics[scale= 0.7]{ctr}\\
\end{center}
\item XTS, o \emph{XEX-based tweaked-codebook mode with ciphertext stealing}\\
Modalità di cifratura applicata su dischi. \\Non possiamo utilizzare $2^{256}$ perché 256 non è un numero primo. E' basato su un polinomio irriducibile di grado 8 sul campo di Galois che ha grado massimo 7, ovvero\begin{center}
 $GF(2^8)$ : $ax^7+bx^6+cx^5+dx^4+ex^3+fx^2+gx^1+ h$ (range dei byte)
 \end{center}
Il polinomio $m(x) = ax^8+bx^7+cx^6+dx^5+ex^4+fx^3+gx^2+ hx^1 + i$ funge da modulo. Il grado è 8 perché quando andiamo ad effettuare il modulo, il risultato sarà sicuramente di grado $<$ $8$ che rientra ancora nel campo di Galois. I termini $a,b,...,i$ appartengono a $Z_2$ (0, 1)\\\\
Consideriamo $(x^7+1)x^7 = x^{14} + x^7$, come possiamo vedere il risultato sfora oltre il range dei byte gestiti.
Come nel cifrario di cesare effettuiamo un modulo, rispetto ad un polinomio $m(x)$ di grado 8
\begin{center}
$x^{14} + x^7 mod(m(x))$
\end{center}
\emph{Ma quale m(x) dobbiamo utilizzare?} \\Selezioniamo un $m(x)$ di grado 8 irriducibile (sono circa 30), ad esempio: \\$m(x) = x^8 + x^4 + x^3 +x+1$\\
Questo polinomio irriducibile è quello che è stato selezionato per AES.\\
Consideriamo $m(x)$, la sua scomposizione è: \\$m(x) * q(x) + r(x)$, e sul campo di Galois la rappresentazione di $m(x)$ è $r(x)$ \\\\
\emph{Cosa succede se ad AES applichiamo un polinomio $m'(x)$, ovvero un altro polinomio di grado 8 irriducibile ?}\\
In questo caso otterremmo un $r'(x)$, ovvero una rappresentazione diversa di $m(x)$

\end{itemize}
\emph{Double-DES | Doppio-DES}\\
Consideriamo un ciphertext cifrato con 2 round di DES, prima con una chiave $k_1$ e poi con una chiave $k_2$. Lo sforzo computazionale per decryptare il ciphertext richiederebbe $2^{56} + 2^{56}$ tentativi ovvero $2^{57}$, rispettivamente per ogni round.
\begin{center}
$C= E(k_2;E(k_1;p))$
\end{center}
\emph{Esiste una chiave $k_3$ che possa passare direttamente da plaintext a ciphertext?}\\
 - La risposta è no\\
 Il problema con questa implementazione è che le chiavi da mantenere diventano 2: $k_1, k_2$. Per arginare questo problema la funzione di encryption diventa:
 \begin{center}
 $C = E_{k_1}(D_{k_2}(E_{k_1}(plaintext)))$\\
 \emph{Ove $E$ è l'operazione di encryption, mentre $D$ è l'operazione di decryption}
 \end{center}
 Questa tecnica è chiamata \emph{Triple-DES o 3-DES} ed è il meccanismo alla base dei pagamenti elettronici. La decryption è effettuata con la chiave $k_2$, che però è diversa dalla chiave $k_1$, aggiungendo ulteriormente entropia.\\Se $k_1 == k_2$ l'operazione di encryption è svolta una sola volta (single DES), che ci permette di comunicare anche con dispositivi datati che non supportano l'encryption basato su più chiavi.
 
 
\section*{AES | Rijndael cipher}
Nel 1997 il NIST indice un nuovo contest per determinare un successore a DES, che verrà chiamato AES. Questo è fatto perché DES, avendo una chiave di 56-bit, era diventato vulnerabile ad attacchi brute force.\\
I 5 cifrari concorrenti arrivati alla finale sono: \emph{Rijndael, Serpent, Twofish, RC6, MARS}, Rijndael è selezionato nel 2001 in base a test di performance, efficienza su hardware datato, e supporto a chiavi di grandezza superiore e variabile.\\\\
In particolare AES:
\begin{itemize}
\item il plaintext ha blocchi di grandezza fissa 128 bits
\item la chiave a grandezza variabile: 128, 192 e 256 bits
\item il ciphertext ha grandezza 128 bits
\end{itemize}
\begin{center}
\includegraphics[scale= 0.4]{AES}
\end{center}
\subsection*{Add-round key}
E' l'operazione di "whitening" e ha l'obiettivo di neutralizzare il potenziale attacco basato su plaintext particolari (tutti 0, tutti 1 etc), consiste in un'operazione di XOR con la chiave colonna per colonna.\\\\
\subsection*{$Round_n$}
Le operazioni all'interno del $round_n$ sono svolte 9 volte e sono:
\begin{itemize}
\item Substitute bytes: corrisponde alle s-box in DES. in base ai valori presenti nello stato, vengono presi i valori all'interno di una matrice. Le s-box in AES sono di dimensione $16 * 16$\\
\emph{Ma come vengono calcolati i valori da inserire all'interno dell's-box?}
\begin{center}
\includegraphics[scale= 0.4]{aesbox}
\end{center}
- Calcoliamo l'inverso moltiplicativo del valore $yx$ (ove. $riga = y$ e $colonna = x$) sul campo di Galois $GF(2^8)$\\
- Il byte risultante lo moltiplico per la matrice M\\
La matrice M è una matrice che è composta da n righe, costruite shiftando progressivamente verso destra il valore la seguente sequenza di bit: \begin{center}
1000 1111\\
1100 0111\\
...\\
fino a raggiungere\\
0001 1111
\end{center}
- Lo sommo per un valore costante C di valore 63\\
Il valore risultate è il valore da inserire all'interno della s-box in riga $y$ e colonna $x$.\\\\
Ricaviamo il valore a partire da 95:\\
- L'inverso moltiplicativo di 95  è $({95})^-1 = 8A$ \\
- Moltiplico l'inverso moltiplicativo per la matrice M (prodotto riga per colonna con la codifica in binario di $8A$)\\
- Faccio la somma con il valore 63 codificato in binario (11000110)\\
Il valore ricavato in riga 9, colonna 5 è 2A
\begin{center}
\includegraphics[scale= 0.3]{sbox3}
\end{center}
\item Shift rows: la prima riga viene lasciata invariata, la seconda viene shiftata di due byte, e la terza viene shiftata di 3 byte.
\item Mix columns: viene moltiplicata una colonna degli stati per una matrice nota, una colonna alla volta.
\item Add round key: un altro round di ARK, tuttavia 
\end{itemize}
\emph{$Round_9 + 1$ | $Round_{10}$}\\
Dopo aver svolto 9 volte le operazioni nel round, vengono effettuate nuovamente \emph{substitute bytes e shift rows}.\\
L'output del decimo round è il ciphertext.\\\\
\emph{Round keys | Key schedule}\\

\subsection*{AES-XTS}
\begin{center}
\includegraphics[scale= 0.4]{aesxts}\\
\end{center}
- AES $k_1$ e $k_2$ sono le due porzioni di chiavi di chiave AES applicate. $k_1$ e $k_2$ hanno dimensione 128, se la chiave AES ha 256 di dimensione. (Sono come il left and right)\\\\
- $i$ e $j$ sono rispettivamente il settore e la traccia del disco e hanno grandezza 128 bit. L'operazione che si svolge con $j$ è quella di prodotto (settore cifrato * traccia (non cifrata)). \\L'output è un polinomio in campo $GF(2^{128})$ con coefficienti su $Z_2$, con modulo $m(x) = x^{128}+x^7+x^2+x+1$\\
- Questo output è utilizzato per fare lo XOR con il plaintext, svolgendo un'operazione di whitening, prima di passare all'operazione di $AES_{k_2}$, passando per un whitening ulteriore abbiamo l'output.\\\\
Siccome i blocchi sono formati da 128 bit, è possibile che ci siano blocchi incompleti. In questi casi sono introdotti dei padding. \\Sia un plaintext diviso in blocchi $P_1, ... P_{m-1}, P_m$ con $P_m$ incompleto, in AES-XTS i blocchi  $P_1, ..., P_{m-2}$ sono gestiti normalmente, mentre i blocchi $P_{m-1}$ e $P_m$ sono gestiti in maniera speciale. In particolare:
\begin{itemize}
\item Il blocco $P_{m-1}$ è passato in AES-XTS, generando 
\begin{center}
$AES-XTS(<P_{m-1}>) = (C_{m}, CP)$
\end{center}
\item il blocco $P_{m}$ è incompleto, ed è complementato da un padding, in particolare n digits dal ciphertext $CP$ del blocco precedente.
\begin{center}
$AES-XTS(<P_m, CP_n>) = C_{m-1}$
\end{center}\end{itemize}
\begin{figure}[H]
\begin{subfigure}[h]{0.4\linewidth}
\includegraphics[width=\linewidth]{cpo}
\caption*{fase di encryption}
\end{subfigure}
\hfill
\begin{subfigure}[h]{0.4\linewidth}
\includegraphics[width=\linewidth]{cpo-1}
\caption*{fase di decryption}
\end{subfigure}%
\end{figure}
La fase di decryption funziona al contrario (figure 2)

\section*{Attacking AES (6 rounds)}

\long\def\comment#1{
\emph{To be reviewed:  $https://www.davidwong.fr/blockbreakers/square_1_3rounds.html$}
}	
La prima cella all'interno della matrice 4x4 è designata e chiamata attiva, gli altri valori sono costanti.
$\Delta - SET$: l'insieme dei valori da 0 e 256 $P_1, ... P_{256}$ ovvero $00, 01, ... , FE, FF$\\
Somma zero (proprietà che ci permette di attaccare AES fino al terzo round): se prendiamo tutti i 256 crittotesti, lo xor su tutit i singoli byte in tutte le posizione la somma è uguale a 0, è una proprietà che vale fino al terzo round (dal round $\geq$ 4 non vale più \\
Le operazioni che vengono svolte sono in ordine : \emph{Add Round Key}, \emph{Substitute Bytes}, \emph{Shift Rows} ed infine \emph{Mix columns}. Possiamo tuttavia notare che le tutte le operazioni non vanno a modificare la posizione dell'active cell
\begin{center}
\includegraphics[scale= 0.4]{active}
\end{center}
Tuttavia, dal secondo round in poi, possiamo vedere che lo stato della cella attiva 1 va ad influire sul valore di tutte le altre.
\begin{center}
\includegraphics[scale= 0.4]{active2}\\
\end{center}
Una minima variazione del plaintext o della chiave va ad influire in maniera esponenziale sul ciphertext. Queste proprietà sono chiamate confusion and diffusion (tutto dipende da tutto). Un bit della chiave va ad influire tutto lo stato di AES\\\\\
$MC(stato)$ $\oplus$ $ARK$ = \\$MC(stato)$ $\oplus$ $MC(MC^{-1}(ARK))$ = \\$MC(stato$ $\oplus$ $MC^{-1}(ARK))$
\begin{figure}[H]
\begin{subfigure}[h]{0.5\linewidth}
\includegraphics[width=\linewidth]{rev}
\end{subfigure}
\hfill
\begin{subfigure}[h]{0.5\linewidth}
\includegraphics[width=\linewidth]{rev2}
\caption*{il pallino è la chiave, mi serve solo il primo byte della chiave}
\end{subfigure}%
\end{figure}
Lo sforzo computazionale è sceso da $2^{64}$ a $2^8* 5 = 2^{40}$, uno nel penultimo round, 4 nei round.
Per 5 round lo sforzo computazionale è $2^{32} * 2^{40} = 2^{72}$.
Guardare sullo stallings\\ \\

\section*{Crittografia asimmetrica}
Come abbiamo visto in precedenza, la crittografia asimmetrica differisce dalla crittografia simmetrica in quanto entrano in gioco più chiavi, le chiavi private. Le chiavi che entrano in gioco nei processi di cifratura e decifratura sono quindi differenti. \\Le chiavi nella crittografia asimmetrica sono di piccola grandezza, in quanto il mantenimento comporta uno sforzo computazionale non indifferente
\begin{center}
Encryption: $E_{pub}(M) = C$ \\
Decryption: $D_{priv}(C) = M$ 
\end{center}
Il processo di scambio di chiavi pubbliche avviene attraverso un processo di \emph{handshake}.
\subsection*{RSA}
E' un algoritmo di cifratura asimmetrica introdotto negli anni 70, il nome proviene dal nome degli inventori (Rivest-Shamir-Adleman). E' un cifrario a chiavi pubbliche, i principali soggetti sono:
\begin{itemize}
\item chiavi pubbliche: $public(n,e)$:\\
- (solitamente) $e = 2^{16}+1$\\
- $n = p * q$
\item chiavi private: $private(p,q,d)$:\\
- $p$ e $q$ sono due numeri (segreti) primi arbitraria grandi, in genere $>$ 1024 bit.\\
Questi valori devono essere grandi, per fornire un alto grado di entropia\\
- $d * e = 1$ $mod(\phi(n))$ (d segreto) \\
- $e$ è un numero casuale tale che $MCD(e, \phi(n)) = 1$
\end{itemize}

Le componenti pubbliche sono $n$ ed $e$, mentre le componenti private sono $p, d, e$\\\\
Alice: a fase di encryption avviene \begin{center}
$M^{e} = C$ $mod$ $n$ ove $M$  $<$ $n$
\end{center}
Bob: la fase di decryption avviene: \begin{center}
$C^d = M$ $mod$ $n$
\end{center}

\textbf{Il valore e}\\
Il valore $e$ è un valore casuale, che tuttavia deve essere scelto tale che valga la seguente condizione $MCD(e, \phi(n))=1$ (con l'applicazione dell'algoritmo di Euclide)\\ \emph{Ma perché viene scelto} $2^{16}+1$ \emph{solitamente?}\\
Consideriamo dove viene applicato: $m^e$ mod $n$, il valore $2^{16} = 65537$ in codifica binaria è: $10000000000000001$\\
Possiamo vedere che la compaiono molti 0, e pochi 1, ogni volta che compare 1 dobbiamo calcolare, quindi se minimizziamo il valore possiamo ridurre il numero di calcoli da effettuare. L'1 finale ci serve perché dobbiamo utilizzare un numero dispari. Il valore è in particolare $e$ perché deve essere coprimo con $d$, verificabile calcolando l'inverso moltiplicativo \\\\Il valore 65537 è scelto perché è un valore sufficientemente grande, che supera di un numero arbitrario di volte la $n$ nel modulo, aumentando lo sforzo computazionale richiesto al momento del calcolo della radice. In particolare quando andiamo a fare il bruteforcing, più grande è il valore $e$, più alto il valore che dobbiamo bruteforcare\\\\
\textbf{Il valore d}\\
Il valore $d$ è calcolato utilizzando l'algoritmo esteso di Euclide\\
\textbf{La fase di decryption ed encryption}\\
Viene utilizzato il $\phi(n)$\\

Per applicare l'algoritmo RSA abbiamo bisogno di un alcuni strumenti:
\subsection*{Coprimi: "l'algoritmo di Euclide" e "piccolo teorema di Fermat"}
Per verificare che due valori a, b siano coprimi, ovvero che $MCD(a, b)=1$ possiamo:
\begin{itemize}
\item Per valori non troppo grandi: per fattorizzare due valori a, b arbitrariamente grandi dobbiamo verificare tutti i numeri primi fino a radice di a. 
\item Per valori grandi utilizzare \emph{l'algoritmo di Euclide}
\end{itemize}
\textbf{L'algoritmo di Euclide per il calcolo dell'MCD}\\
L'algoritmo di Euclide è un algoritmo efficiente utilizzato per calcolare l'MCD di due valori interi. Se l'output dell'algoritmo di Euclide per due valori $a,b$ è 1 allora possiamo concludere che due valori sono coprimi.
\begin{center}
$a = bq_1 + r_1$\\
$b = r_1 q_2 + r_2$\\
$r_1 = r_2q_3 + r_3$\\
...\\
$r_{k-2} = r_{k-1}q_k+r_k$\\
$r_{k_-1} = r_kq_{k+1} + 0$\\
\end{center}
Se ci troviamo in questa situazione l'algoritmo di Euclide ha trovato resto uguale a 0.\\
L'MCD è quindi $MCD(a,b) = r_k$\\
Proviamo a fare il calcolo con $a = 1180, b= 482$
\begin{center}
$1180 = 482*  2 +216$\\
$482 = 216*2+50$\\
$216 =50*4+16$\\
$50=16*3+2$\\
$16=2*8+0$
\end{center}
Possiamo concludere che $l'MCD(1180, 482) = 2$\\\\
\textbf{L'algoritmo di Euclide esteso per l'inverso moltiplicativo}
\begin{center}
consideriamo $MCD(a,b) = ax+by$\\
\end{center}
\emph{Come calcoliamo x e y?}\\
Partiamo da x:\begin{center}
$x_0 = 0$\\
$x_1 = 1$\\
$x_2 = -q_{j-1} * x_1+x_0$\\
...\\
$x_j = -q_{j-1} * x_{j-1} + x_{j-2}$
\end{center}
Per calcolare y invece: \begin{center}
$y_0 = 1$\\
$y_1 = 0$\\
...\\
$y_j = -q_{j-1}*y_{j-1}+y_{j-2}$
\end{center}
Considerando $MCD(1180,482) = 2 = 1180y+482x$
\begin{center}
$x_0 = 0$\\
$x_1 = 1$\\
$x_2 = -2(1)+0 = -2$\\
$x_3 = -2(-2)+1= 5$\\
$x_4 = -4(5)-2 = -22$\\
$x_5 = -3(-22)+5 = 71$\\
Ricaviamo che $x = 71$\\
\end{center}
\begin{center}
$y_0 = 1$\\
$y_1 = 0$\\
$y_2 = -2(0)+1 = 1$\\
$y_3 = -2(1)+0= -2$\\
$y_4 = -4(-2)+1 = 9$\\
$y_5 = -3(9)-2 = -29$\\
Ricaviamo che $y=-29$
\end{center}
Allora abbiamo che $MCD(1180,482) = -29(1180) + 71(482) = 2$\\\\
L'inverso moltiplicativo deve essere $= 1$, ovvero $ax+by =MCD(a,b)=1$
Poniamo noi l'inverso moltiplicativo =1 perché il processo di decifratura è unica, se avessimo 2 ci sarebbero più decifrature possibili
\begin{center}
$by \equiv 1$ mod $a$\\
$by \equiv 1 + tot * a$ ove $tot = x$\\
$y*b = 1$ mod $a$
\end{center}


\textbf{Teorema piccolo di Fermat ed il teorema di Eulero}\\
Il teorema piccolo di Fermat dice che se $p$ è un valore primo, per ogni intero $a$, il valore $a^p-a$ è un intero multiplo di $p$.
\begin{center}
$a^p \equiv a$ $(mod$ $p )$  oppure  $a^{p-1}\equiv 1$ $(mod$ $p )$
\end{center}
Attraverso il \emph{teorema di Eulero} possiamo generalizzare il teorema di Fermat, in particolare: per ogni modulo $n$ ed ogni intero $a$ coprimo rispetto a $n$ abbiamo:
\begin{center}
$a^{\phi(n)} \equiv 1$ $(mod$ $n)$
\end{center}
Ove $\phi(n)$ rappresenta la funzione di Eulero, che conta il numero di interi fra 1 e $n$ coprimi rispetto ad n. Se $n = p$ è un numero primo allora 
\begin{center}
$\phi(p) = p-1$
\end{center}
Vediamo un esempio di applicazione del piccolo teorema di Fermat.\\
Supponiamo di voler calcolare $2^{43210}$ $mod$ $101$.
\begin{center}
Trasformiamo l'esponente: $43210$ in  $432*100 + 10$\\
$(2^{100})^{432}  * 2^{10}$ mod $101$\\ 
Teorema di Fermat: \\$a^{p-1}\equiv$ mod $p$\\
Allora $1^{432} * 2^{10} $ mod 101\\
Infine: $1024$ mod $101 = 14$
\end{center}
\section*{Attacking RSA}
Siccome il cifrario RSA è stato introdotto nel 1970, durante gli anni sono stati eseguiti numerosi attacchi, che vertono sulle problematiche algoritmiche, matematiche ed ingegneristiche. 
\subsection*{$\phi$(n) accessibile}
Consideriamo un caso in cui l'attaccante sia in grado di accedere al valore $\phi(n)$, magari attraverso ad un dump della memoria dopo che un programmatore l'ha utilizzato, senza cancellare il valore. Siccome i valori della chiave pubblica sono $(n, e)$, abbiamo i seguenti valori disponibili: $(n, e, \phi)$. Se effettuiamo:
\begin{center}
$n-\phi(n)+1 =$\\
$=pq-[(p-1)(q-1)]+1=$\\
$=pq-[pq-p-q+1]+1=$\\
$=p+q$
\end{center}
Deduciamo che se troviamo $\phi$ possiamo ricavare $p+q$. \\Consideriamo ora che $n=p*q$ e $\phi(n) = (p-1)(q-1)$
\begin{center}
$ax^2+bx+c$ \\ove $c = p*q = n$, $a =1$, \\$b = p+q$, che ricaviamo a partire da $n-\phi(n)+1$\\
$x_1x_2 = c/a$\\
$x_1+x_2 = -b/a$
\end{center}
Possiamo quindi ricavare che\begin{center}
$x^2-x(n-\phi(n)+1)+n=0$\\
Se risolviamo con il $\Delta$ possiamo ricavare i valori $x_1 = p $ e $x_2 = q$
\end{center}
\subsection*{Caso valido su d}
Riguardareeeeee
\begin{center}
Se MCD(a,n) = 1
Allora esiste un vlore s,t tle che s >= 0; t > 0
Allora in questo caso esiste 
\end{center}

\subsection*{Casi particolari su d}
Per l'algoritmo di Euclide esteso abbiamo messo come condizione che \begin{center}
$MCD(a,n) = d = 1$
\end{center}
Ma cosa succede se non fosse così?
\begin{center}
$MCD(a,n) = d != 1$\\
$ax \equiv b$ $mod$ $n$
\end{center}
Possiamo dire che:\begin{itemize}
\item se d non divide b, allora non esiste soluzione per $ax \equiv b$ $mod$ $n$
\item se d divide b, allora esiste soluzione per $ax \equiv b$ $mod$ $n$, ma non è unica, la congruenza iniziale avrà $d$ soluzioni. Per decifrare provare più soluzioni, scartando quelle che non mi interessano
\begin{center}
$ax \equiv b$ $mod$ $n$\\
$ax/d \equiv b/d$ $mod$ $n/d$
\end{center}
Chiamiamo la prima soluzione $x_0$, per calcolare le successive soluzioni possiamo
\begin{center}
$x_0 + n/d$, $x_0 + 2n/d$ ,..., $(d-1)(n/d)$
\end{center}
Le soluzioni sono quindi $(d-1)$

\end{itemize}

\subsection*{m/4 cifre esposte di p, q, d}
Supponiamo di avere\begin{center}
$n = p * q $ di $n$ cifre
\end{center}
Se siamo in grado di recuperare le prime $m/4$ cifre di $p$ o di $q$ esiste un attacco in tempo polinomiale in grado di fattorizzare $n$. Questo attacco è stato successivamente esteso, in particolare se sono in grado di recuperare le prime $m/4$ cifre di $d$  sono ancora una volta in grado di rompere RSA
\subsection*{Common modulus attack}
Consideriamo:
\begin{center}
$Alice = (e_A, n)$ | $Bob = (e_B, n)$
\end{center}
Cosa succede se sia Alice che Bob utilizzano uno stesso $p,q$, e di conseguenza $n$?
\begin{center}
$M^{e_A} = C_1$ $mod$ $n$\\
$M^{e_B} = C_2$ $mod$ $n$
\end{center}
Consideriamo un terzo soggetto Carl, che deve inoltrare un messaggio ad Alice e Bob, cifra i messaggi:
\begin{center}
Crittotesto per Alice: $M^{e_A} = C_1$ $mod$ $n$\\
Crittotesto per Bob: $M^{e_B} = C_2$ $mod$ $n$
\end{center}
Se Eve è in grado di recuperare i crittotesti $C_1$ e $C_2$, e nota che gli $n$ di Bob e Alice sono congruenti
Consideriamo \begin{center}
$MCD(C_1, n ) = 1$\\
\end{center}
\begin{center}
\includegraphics[scale= 0.7]{exponent}
\end{center}
\begin{center}
\includegraphics[scale= 0.7]{exponent2}
\end{center}
Come possiamo vedere Eve è stata in grado di recuperare il messaggio $m$ sfruttando una vulnerabilità $n$ comune
\subsection*{Low exponent attacks}
Consideriamo $(e,n)$, \begin{center}
$d* e \equiv 1$ $mod$ $\phi(n)$, con d$\in [1, ..., \phi(n)]$\\
Se $d < 1/3\sqrt[4](n)$
\end{center} 
Esiste un algoritmo in grado di attaccare la chiave in pochi millisecondi
\subsection*{Short plaintext attack}
Attacco probabilistico attuabile nel caso in cui un plaintext sia troppo piccolo, in particolare un plaintext cryptato con DES avrà ordine di grandezza di $m = 10^{17} \equiv 2^{56}$. Il valore $m$ è ri-scrivibile come \begin{center}
$m = a*b$
\end{center}
$a,b$ avranno, con una probabilità non trascurabile, un ordine di grandezza di $10^9$ (valore preso accettabile per un computer diffuso)
Li suddivido ora in due array di $10^9$ elementi, in particolare ricavati rispettivamente con
\begin{center}
$array_1$ = $c*x^{-e}$ $mod$ $n$\\
$array_2$ = $y^e$ $mod$ $n$\\
Con $x, y$ che sono gli indici negli array
\end{center}
\begin{center}
\includegraphics[scale= 0.7]{m1}
\end{center}
In una posizione arbitraria in ogni array sarà possibile trovare 2 celle con lo stesso valore, uguagliando il contenuto dei due array è possibile ricavare il messaggio.
\begin{center}
\includegraphics[scale= 0.7]{m2}
\end{center}
In particolare ho trovato i fattori $x * y$, ricavando cosi il valore $m$
\subsection*{Padding per short plaintexts | OAEP}
Per raggirare il problema di plaintext troppo corto viene aggiunto un padding, ovvero una stringa definita, inserita in coda al plaintext. In particolare per RSA viene utilizzato l'\emph{OAEP} (optimal asymmetric encryption padding), il cui valore è generato da una funzione Feistel (la parte della generazione del padding è ignorata). Per criptare plaintext corti, quindi, viene generato un padding di lunghezza $x$.\\
Dato un messaggio troppo corto $M$ di lunghezza $i$, il messaggio unito col padding $P$ con lunghezza $k$ diventa:	\begin{center}
$M_i \rightarrow$ $M_iP_k$

\end{center}
$M_iP_k$ è poi utilizzato per produrre il ciphertext


\subsection*{Teorema cinese dei resti}
Permette di fare il calcolo dell'inverso attraverso la risoluzione di sistemi, che permette di scaricare il carico computazionale al server
Consideriamo un set di numeri interi o naturali:
\begin{center}
$for$ $i$ 	$P_i/Z_i = r_1r_2...r_{i-1}r_{i}$\\
$for$ $i$ 	$Q_i/Y_i = Z^{-1}_i$ $mod$ $r_i$\\
$x = a_1y_1z_1+ ... + a_ny_nz_n$\\
\end{center}
Questo viene fatto perché il calcolo dell'inverso moltiplicativo nel metodo tradizionale è un'operazione dispendiosa. La risoluzione del sistema risulta meno dispendiosa, e ci permette anche a scaricare il server ad un'altra location.
\subsection*{Lemma del teorema cinese dei resti}
Consideriamo due interi $m, n$ coprimi fra loro, ovvero:
\begin{center}
$m,n$ t.c. $MCD(m,n) = 1$
\end{center}
Se $c$ un altro intero è multiplo di $m$ e $n$ \begin{center}
ovvero $c = m*k$, $c = n*l$\end{center}
 allora 
 \begin{center}
 $c$ è multiplo di $(m*n)*x = c$
 \end{center}
\subsection*{Lemma del teorema cinese dei resti}
Consideriamo:\begin{center}
$(m^e)^d = m$ $mod$ $n$
\end{center}
Consideriamo 2 dei 4 casi possibili su $m$
\begin{center}
$MCD(p,m) \neq 1 = d$
\end{center}
Allora $p$ ed $m$ hanno qualcosa in comune, in particolare $d=  p$ , e $p | m$, di conseguenza
\begin{center}
$M \equiv 0$ $mod$ $p$\\
Consideriamo $e*d = 1$ $mod$ $\phi(n)$\\
$M^{ed} \equiv M^{k(p-1)(q-1)+1}$ $mod$ $p$\\
\end{center}
\emph{TO REVIEW}

\subsection*{Timings attacks}
Un attacco notato per la prima volta da uno studente della Stanford 20 anni dopo l'implementazione di RSA. Questo attacco espone informazioni private misurando l'ammontare di tempo richiesto o analizzando l'oscillazione durante le operazioni svolte sulla chiave privata.\\
Possiamo raggirare questa problematica offuscando l'implementazione, rendendo il tempo d'esecuzione costante (per esempio introducendo una serie di nop), in alternativa attraverso la tecnica di sliding windows, si effettuano i calcoli su un subset di bits. 

\section*{Chiavi RSA}
Consideriamo i valori $p,q$, due numeri primi, abbiamo detto che questi valori devono essere arbitrariamente grandi per garantire un buon grado di sicurezza\\
\emph{Ma come verifichiamo che un numero sia adatto?}\\
Siccome non possiamo utilizzare un algoritmo deterministico per determinare $n$, in quanto il calcolo dei numeri primi non è deterministico, utilizziamo un approccio probabilistico. Andiamo a verificare il valore $n$ con una serie di test per escludere valore inadatti.\\
In modo per determinare un valore $n$ adatto è il seguente:
\begin{itemize}
\item determiniamo un lower bound di $10^{100}$, determiniamo un valore $P_0 = \cong10^{40}$
\item verifichiamo con $P_0$ con Miller Rabin
\item determiniamo un valore $k$ tale che $P_o * k$ $\cong$ $10^{100}$, $k$ sarà dell'ordine di $10^{60}$
\item $p_0 * k+1 = p$, applichiamo Miller Rabin $n$ volte, se passa, $p$ è primo
\end{itemize}
Questo ci permette di evitare l'attacco di Pollard in quanto il valore è $p-1$ è sicuramente un valore non basso.
\subsection*{Test di primalità di Fermat}
Consideriamo
\begin{center}
$n, x, y$ tale che $x^2 \equiv y^2$ $mod$ $n$\\
se $n \neq \pm y \rightarrow$ $n$ è composto
\end{center}
In particolare
\begin{center}
$MCD(x-y; n)$ fornisce un fattore di $n$
\end{center}
Consideriamo ora \begin{center}
$n$ un intero arbitrariamente grande\\
$\pm a < n-1$\\
se $a^{n-1} = d$ $mod$ $n$\\
Ovvero che $a^{n-1} \neq 1$ $mod$ $n$
\end{center}
allora possiamo concludere che $n$ è  un numero composto, per il piccolo teorema di Fermat.
se invece: 
\begin{center}
se $a^{n-1} = 1$ $mod$ $n$
\end{center}
Non possiamo concludere nulla su $a$. Il teorema piccolo di Fermat è quindi utilizzato per verificare che un numero è composto.\\

Siccome non siamo stati in grado di determinare nulla su $a$, utilizziamo un altro test, in particolare 
il test di Miller-Rabin
\subsection*{Test di primalità di Miller Rabin}
Consideriamo un valore primo dispari $n$ da verificare
\begin{center}
$n-1 = 2^k * m$
\end{center}
Consideriamo: 
\begin{center}
$a < n-1$\\
\end{center}
Andiamo ad applicare l'algoritmo di Miller Rabin
\begin{center}
$b_0 = a^m$ $mod$ $n$
\end{center}
Se $b_0$ è uguale a \begin{itemize}
\item +/- 1 allora $n$ è probabilmente primo
\item altro, allora proseguiamo con $b_1$
\end{itemize}
\begin{center}
$b_1 = b^2_0$ $mod$ $n$
\end{center}
Se $b_1$ è uguale a \begin{itemize}
\item +1 allora $n$ è composto
\item -1 allora $n$ è probabilmente primo
\item altro, allora proseguiamo con $b_2$
\end{itemize}
In particolare $b_2$ viene calcolato nella stessa maniera in cui è calcolato $b_1$, elevando alla seconda il valore $b_{m-1}$ e modulando.\begin{center}
$b_k = (b_{m-1})^2$ $mod$ $n$
\end{center}
L'algoritmo termina quando calcoliamo il valore $b_{k-1}$, in particolare se $b_{k-1}$ è uguale a \begin{itemize}
\item +1 allora $n$ è composto
\item -1 allora $n$ è probabilmente primo
\item altro, allora scegli un altro valore $n$ da verificare
\end{itemize}
L'algoritmo di Miller Rabin ha una probabilità di errore del 25\%, un risultato su 4 è errato. 

Tuttavia 25\% non è soddisfacente, per mitigare la probabilità l'algoritmo di Miller Rabin è applicato più volte su $j$ valori diversi, in particolare se la probabilità è 25\% per una verifica, per 10 verifiche la probabilità di errore diventa
\begin{center}
$(1/4)^{10}$
\end{center}
I valori che passano il test di Fermat sono chiamati \emph{pseudoprimi}, mentre quelli che passano sia Fermat che Miller Rabin sono chiamati \emph{pseudoprimi forti}
Consideriamo \begin{center}
$n = 13 \rightarrow n-1 = 12 = 2^2*3$
prendiamo a = 11\\
$b_0 = 11^3$ $mod$ $13$
$b_0  = 5$
$b_1 = 25 mod 13 -> 12$
$b_2 = 144 mod 13$
\end{center}
Le banche utilizzano Fermat, Miler Rabin, Solovay–Strassen per effettuare test di primalità.


\subsection*{Fattorizzazione di n}
Dato un valore $n$ composto, come possiamo fattorizzarlo nei valori $p, q$?
Introduciamo la tecnica di fattorizzazione di Fermat. Consideriamo $n,i,j$ tale che
\begin{center}
$n+i^2 = j^2$
\end{center}
Allora possiamo fattorizzare $n$, infatti:
\begin{center}
$n = j^2 - i^2=$\\
= (j+i)(j-i)
\end{center}
Ad esempio consideriamo $n = 295927$
\begin{center}
$n+1^2 = j^2$
\end{center}
se è possibile abbiamo finito, senò proseguiamo:
\begin{center}
$n+2^2 = j^2$\\
$n+3^2 = 295936 = 544^2$\\
$n = (544+3)(544-3)=$\\
$n = 547 * 541$
\end{center}
Abbiamo trovato che $p = 547, q = 541$. La difficoltà sta nel trovare i valori $i, j$, in quanto la ricerca di tali valori è lenta.
\subsection*{Fattorizzazione di n | algoritmo di Pollard}
Consideriamo\begin{center}
$n = p * q$
\end{center}
Se è possibile scriver $p-1$ come un prodotto di numeri primi piccoli, allora il valore $p$ è facilmente attaccabile con l'algoritmo di Pollard. Ad esempio:
\begin{center}
$p-1 = 2^{101} * 3^7 * 5^{10} * 7^ {701}$
\end{center}
Come possiamo vedere i tali valori sono "piccoli", il valore $p$ non è adatto.

\subsection*{Quadrato di Sieve}
Il quadrato di Sieve è un algoritmo per la fattorizzazione (sieve = setaccio).
Consideriamo \begin{center}
$n = p * q$
\end{center}
Selezioniamo $k$ valori su cui applicare $mod$ $n$.
\begin{center}
$123456 ^2$ $\equiv x$ $mod$ $n$ 
\end{center}
Supponiamo che $x = 2^3*3^4*11*23^2$, continuiamo provando con $n$ valori $x_n$

\begin{center}
$n = 3837523$
\end{center}
Selezioniamo $k$ valori su cui applicare $mod$ $n$, più valori scegliamo , più precisa sarà la nostra stima. Ad esempio scegliamo 9398, 19095, 1964, 17078
\begin{center}
$9398^2 = 5^5 * 19$ $mod$ $n$\\
$19095^2 = 2^2 * 5 * 11 * 13 * 19$ $mod$ $n$\\
$1964^2 = 3^2 * 13^3$ $mod$ $n$\\
$17078^2 = 2^6 * 3^2 * 11$ $mod$ $n$\\
...
\end{center}
I valori a sinistra sono tutti valori al quadrato, moltiplicandoli tra di loro avremo sicuramente un valore quadrato, in particolare:
\begin{center}
$(9398 * 19095 * 1964 * 17078)^2$
\end{center}
Il valore all'interno delle parentesi lo chiamiamo $x$.
I valori a destra invece abbiamo $n$ valori con la stessa base, progressivamente moltiplichiamo tra loro e ricaviamo:
\begin{center}
$2^8*3^4*5^6*11^2*13^4*19^2$
\end{center}
Notiamo che tutti questi valori hanno una potenza quadrata, possiamo quindi riscriverla così:
\begin{center}
$(2^4*3^2*5^3*11*13^2*19)^2$
\end{center}
Il valore all'interno delle parentesi lo chiamiamo $y$.
\begin{center}
$x^2 \equiv y^2$ $mod$ $n$\\
Allora $n$ è composto e posso trovare uno dei due fattori di $n$ facendo: $x \neq \pm y\rightarrow$ $ (MCD(x-y; n) = d \neq 1$\\
Valore che è uguale a $p$ o $q$
\end{center}

\section*{Problema del logaritmo discreto}

\begin{center}
$\alpha^x \equiv \beta$ $mod$ $p$
\end{center}
Come faccio a trovare $x$? La cosa più intuitiva sarebbe utilizzare il logaritmo
\subsection*{Baby step giant step}
Il primo approccio è quello di utilizzare il \emph{baby step giant step}\\
Creiamo due vettori di grandezza $p$ (ovvero il modulo) in cui vengono inseriti gli elementi $\alpha_j$ nel primo vettore, $\beta\alpha^{-Nk}$ nel secondo vettore. Cerchiamo poi due valori comuni, per poi effettuare l'uguaglianza. 
\begin{center}
\includegraphics[scale= 0.7]{rev1}
\end{center}
In particolare l'uguaglianza
\begin{center}
$\alpha^j \equiv \beta * \alpha^{Nk}$ $mod$ $p$
\end{center}
E' uguale a 
\begin{center}
$\alpha^{j+NK} \equiv \beta$ $mod$ $p$
\end{center}
Ricordiamo che:
\begin{center}
$\alpha^x \equiv \alpha^y$ $mod$ $p$\\
$x \equiv y$ $mod$ $p-1$\\
$\alpha^{p-1}\equiv 1$ $mod$ $p$
\end{center}

\subsection*{analisi su parità o meno di x}
Per dividere in 2 il sample size
\emph{su carta}

\subsection*{Index calculus}
E' una variabile del quadratic sieve basato su \begin{itemize}
\item un passo di precomputazione
\item calcolo dei logaritmi 
\item un passo di controllo proprietà, in particolare se è scomponibile
\end{itemize}
Consideriamo\\
\begin{center}
$\beta \equiv \alpha^x$ $mod$ $p$\\
$log_\alpha \beta = x$ $mod$ $(p-1)$
\end{center}
Consideriamo $a^k$ così definito:
\begin{center}
$a^k = \Pi p_i^{a_i}$ $mod$ $p$ ove $\Pi$ è la produttoria 
\end{center}
Allora il passo computazionale è il seguente:
\begin{center}
$k = log_\alpha (\Pi p_i ^{a_i})$
$= \sum a_i log_\alpha p_i$ $mod$ $p-1$
\end{center}
Questo ci permette di mettere in evidenza i logaritmi.
Il valore $\beta$ lo moltiplichiamo per un valore $a$ elevato ad un valore $r$ random, che ci permette di espanderlo nel seguente modo:
\begin{center}
$\beta * \alpha ^ r = \Pi p_i^{b_i}$ $mod$ $p$\\
$log_\alpha \beta + r log_\alpha \alpha = 
$=$ \sum b_i log_a p_i$ $mod$ $p-1$
\end{center}
Possiamo esporre quello che ci serve:
\begin{center}
$log_\alpha \beta = -r + \sum b_i log_a p_i$ $mod$ $p-1$
\end{center}
Abbiamo quindi trovato $x$, dato che $x = log_\alpha \beta$. Dobbiamo scegliere un $r$ adeguato che mi generi un $p_i$ sufficientemente piccolo per garantire che l'abbia generato in precedenza
\begin{center}
$p = 131$ $\alpha = 2$\\
$B = soglia = 10$ $\beta = 37$
\end{center}
La soglia va ad influire sui valori possibili di $p_i$ in particolare questi valori devono essere minori della soglia, definita in base alle capacità computazionali del sistema, in questo caso:
\begin{center}
$p_i = 2, 3, 5, 7$
\end{center}
\subsubsection*{Vediamo un esempio pratico}
Impostiamo il problema:
\begin{center}
$\beta = \alpha ^x $ $mod$ $p$\\
$37 = 2^x$ $mod$ $131$
\end{center}
Calcolo gli $\alpha^k$, tale che $alpha^k$ è scomponibile in un prodotto numeri primi minori della soglia, ovvero il passo di precomputazione $a^k = \Pi p_i^{a_i}$ $mod$ $p$ :
\begin{center}
$2^1 = 2$ $mod$ $131$\\
...\\
$2^8 = 5^3$ $mod$ $131$\\
...\\
$2^12 = 5*7$ $mod$ $131$\\
...\\
$2^14 = 3^2$ $mod$ $131$\\
...\\
$2^34 = 3*5^2$ $mod$ $131$\\
...
\end{center}
Calcoliamo ora $k$: $k = log_\alpha (\Pi p_i ^{a_i})$.\\
Siccome stiamo introducendo i logaritmi passiamo a $mod$ $p-1$
\begin{center}
$1 \equiv log_2 2$ $mod$ $130$\\
$8 \equiv 3log_2 5$ $mod$ $130$\\
$12 \equiv log_2 5 + log_2 7$ $mod$ $130$\\
$14 \equiv 2log_2 3$ $mod$ $130$\\
$34 \equiv log_2 3 + 2log_2 5$ $mod$ $130$
\end{center}
Possiamo procedere con l'esplicitazione dei logaritmi, se questi sono invertibili
\begin{center}
$log_2 2 = 1$ $mod$ $130$\\
$log_2 5 = 5*87 = 46$ $mod$ $130$\\
$log_2 3 = 72$ $mod$ $130$\\
$log_2 7= 12-46 = -34 = 96$ $mod$ $130$\\
\end{center}
Continuiamo con $\beta * \alpha ^ r = \Pi p_i^{b_i}$ $mod$ $p$
\begin{center}
$37 * 2^{43} = 3 *5 * 7$ $mod$ $131$\\
$log_2 37 + 43 log_2 2 = log_2 3 + log_2 5 + log_2 7$\\
$log_2 37 = -43 + log_2 3 + log_2 5+ log_2 7$\\
$ x = -r \sum b_i log_a p_i$
\end{center}

\section*{Logaritmo discreto}



\subsection*{Casi d'uso del logaritmo discreto}

\subsection*{Diffie Hellman}
L'algoritmo del logaritmo discreto è utilizzato ogni giorno per lo scambio delle chiavi secondo l'algoritmo di Diffie-Hellman, che permette di scambiare le chiavi su un canale insicuro\\
Supponiamo $\alpha, p$ due valori pubblici, e le due chiavi $x, y$ possedute da Alice e Bob, come possono scambiare le chiavi su un canale insicuro?
\begin{center}
\includegraphics[scale= 0.5]{dellman}
\end{center}
\subsubsection*{Problemi con Diffie Hellman}
Consideriamo Alice, Bob ed un attaccante Eve. L'algoritmo di Diffie Hellman ci dice che:
\begin{center}
Alice spedisce $\alpha^x$ $mod$ $p$\\
Bob spedisce $\alpha^y$ $mod$ $p$\\
 \end{center}
 Consideriamo Eve che riesce a fare un attacco man in the middle:
 \begin{center}
 Eve possiede $\alpha^z$ $mod$ $p$\\
 Eve intercetta $\alpha^x, \alpha^y$
 \end{center}
 Eve procede a inoltrare il valore tampered $\alpha^z$ ad Alice e Bob, che rispettivamente svolgono:
 \begin{center}
 Alice: $(\alpha^z)^x$ | Bob: $(\alpha^z)^y$
 \end{center}
 Eve è in grado di intercettare i due valori $x$ e $y$, e ciò gli permette di leggere e contraffare tutti i messaggi.
\begin{center}
\includegraphics[scale= 0.5]{ld1}
\end{center}

Per raggirare questo problema è stato implementato STS, un sistema di firme digitali per garantire l'autenticità


\subsection*{Bit commitment}
Un'altra applicazione del logaritmo discreto è durante l'utilizzo del bit commitment, o schema di commitment. questo ci permette di mostrare il possedimento di un dato valore senza mostrarlo. E' poi possibile mostare il dato valore in futuro.
\begin{center}
$\alpha^x = \beta$ $mod$ $p$
\end{center}

\subsection*{ElGamal}
E' un algoritmo di cifratura a chiave asimmetrica. Consideriamo \begin{itemize}
\item Alice con un messaggio $m$
\item Bob che sceglie $\alpha$ radice primitiva, $\phi$ numero primo, a numero segreto
\end{itemize}
Bob computa:
\begin{center}
$\alpha^a \equiv \beta$ $mod$ $p$\\
Valori da pubblicare: $(\alpha, p, \beta)$
\end{center}
Alice per cifrare il proprio messaggio scarica le informazioni pubbliche di bob $(\alpha, p, \beta)$, genera un valore $k$ casuale segreto. A partire da $k$ calcola $r,t$, in particolare:
\begin{center}
$r = \alpha^k$ $mod$ $p$\\
$t = \beta^k  * m$ $mod$ $p$
\end{center}
La coppia $(r,t)$ rappresenta il messaggio cifrato da spedire a Bob. Bob per decifrare effettua:
\begin{center}
$t * r^{-a} \equiv m$ $mod$ $p$
\end{center}
Stiamo incorporando il messaggio all'interno del problema del logaritmo discreto, che l'attaccante non riesce a bucare.
\subsection*{Dimostrazione di corretta di ElGamal}
Consideriamo: \begin{center}
$t * r^{-a} = (\beta^k * m)(\alpha^k)^{-a}=$\\
$= [(\alpha^a)*m^k]*(\alpha^k)^{-a} = m$ $mod$ $p$
\end{center}
\subsection*{Problematiche con ElGamal}
\subsubsection*{Valore k comune}
Consideriamo Alice con due messaggi $m_1, m_2$, cosa succede se Alice cifra due messaggi con $k$ uguale. Alice cifra:
\begin{center}
$(r, t_1) | (r, t_2)$
\end{center}
Siccome $r$  è una componente pubblica, l'attaccante può vedere senza problemi che Alice ha utilizzato un $k$ uguale per entrambi i messaggi. L'attaccante conosce $t_1, t_2$, ma non i valori a destra dell'uguale:
\begin{center}
$t_1 = \beta^k * m_1$ $mod$ $p$\\
$t_2 = \beta^k * m_2$ $mod$ $p$
\end{center}
L'attaccante tuttavia sa che:
\begin{center}
$t_1/m_1 = \beta_k = t_2/m_2$
\end{center}
Può computare il messaggio facendo:
\begin{center}
$m_2 = t_2  * m_1/t_1$
\end{center}

\section*{Funzioni Hash}
Una funzione hash è una funzione matematica/crittografica. Le principali caratteristiche delle funzione hash sono:\begin{itemize}
\item la facilità di computazione
\item l'input può essere una stringa di una qualsiasi dimensione
\item l'output ha una dimensione fissa, specifica per ogni funzione hash
\end{itemize}
Alcuni esempi di funzioni hash sono SHA1, SHA256, MD5, SHA3 etc.

\subsection*{Collision free property}
Una funzione di hash è perfetta se è iniettiva, ovvero se $u = v$, $h(u) \neq h(v)$, più una funzione di hash sparpaglia gli elementi, meglio è. E' tuttavia possibile che due elementi abbiamo una stessa chiave, in questo caso parliamo di $collisione$. \\
Le collisioni comportano che un output della hash function abbia 2 input medesimi. E' tuttavia possibile trovarli?
\begin{center}
\includegraphics[scale= 0.5]{h1}
\end{center}
Se vengono computati i valori hash di $2^{130}$ stringhe, la probabilità di trovare 2 valori con lo stesso output hash è del 99\%. E' tuttavia un valore cosi astronomicamente alto che è possibile considerarla nulla.\\
Possiamo quindi considerare che le funzioni hash siano collision free (non proprio, ma non importa). Possiamo quindi considerare che:
\begin{center}
$H(x) = H(y) \rightarrow x = y$
\end{center}

\subsection*{Pre-image resistance}
\begin{center}
\includegraphics[scale= 0.5]{h2}
\end{center}
Consideriamo un valore hash $H(x)$, è computazionalmente impossibile ricavare $x$, ovvero la funzione non è reversibile (a partire da un valore hashato, non posso risalire alla fonte). In particolare la funzione hash è chiamata one-way. Possiamo quindi concludere che per nascondere un messaggio $x$, è possibile nasconderlo con $H(x)$
\subsection*{Second pre-image resistance}
\begin{center}
\includegraphics[scale= 0.5]{h3}
\end{center}
Dato un valore $x$, è computazionalmente impossibile trovare un valore $y$ tale che $H(x) = H(y)$.

\subsection*{SHA1}
SHA1 è una funzione hash crittografica che produce hash values di lunghezza 160. SHA1 lavora svolgendo 80 round della seguente funzione:
\begin{center}
\includegraphics[scale= 0.5]{sh1}\\
\emph{Ogni 20 round la funzione $f$ ed il valore $k$ cambiano}
\end{center}

\begin{itemize}
\item I blocchi A, B, C, D sono blocchi di 32 bit\\
In particolare i blocchi A, B, C, D sono inizializzati con valori in big endian con valore esadecimale in ordine crescente:
\begin{center}
\includegraphics[scale= 0.5]{blocks}
\end{center}
I valori costanti presenti nei blocchi cambiano dal passo $n_2$ in poi. Dopo 80 round di SHA1, questo output è utilizzato come valore costante iniziale per i blocchi successivi
\item $F$ è una funzione lineare
\item $<<<$ rappresenta una funzione di shift, rispettivamente di 5 e 30 posizioni
\item $W_t$ rappresenta il plaintext del round $t$, di grandezza 512 bit.\\
Consideriamo un messaggio $m$ (la divina commedia) di lunghezza $n$ ($n$ lunghezza arbitraria), il messaggio $m$ è diviso in $k$ blocchi di grandezza 512, questi 512 bit sono divisi in blocchi $W_j$ da 32 bit ciascuno.\\ In particolare se il messaggio è lungo 512 bit, questo ci produrrà 16 blocchi che rappresentano rispettivamente un valore di $W_j$ da 32 bit $(16*32 = 512)$.\\
\emph{Ma io ho bisogno di fare 79 rounds, e ne ho solo 16, cosa faccio?}
\begin{center}
\includegraphics[scale= 0.5]{blocks2}
\end{center}
Dal round 16 in poi, quindi, vengono presi 3 blocchi, e $XOR$ati tra di loro, per poi effettuare un $leftrotate$
\item $K_t$ è una costante, valore che dipende dal numero di round in cui ci troviamo
\begin{center}
\includegraphics[scale= 0.5]{blocks3}
\end{center}
\item Infine svogliamo una semplice somma per rendere SHA1 immune ad attacchi semplici:
\begin{center}
\includegraphics[scale= 0.5]{blocks4}
\end{center}
\end{itemize}

\subsection*{SHA1 | password hashing}
Consideriamo di voler hashare una password, queste essendo solitamente corte potremmo trovarci in una situazione in cui non riusciamo a riempire neanche il primo blocco $W_k$:
\begin{center}
\includegraphics[scale= 0.5]{blocks5}
\end{center}
Utilizziamo quindi un padding, in particolare vengono aggiunti un bit di $1$ ed $n$ bit $0$, in particolare $n$ fino al 448 bit. Nei rimanenti 64 bit inseriamo:
\begin{center}
\includegraphics[scale= 0.5]{blocks6}
\end{center}
In particolare il 5to ed il 4to bit da destra vengono settati ad 1 in quando la lunghezza della parola Andrea è $48 bit = 32 + 16 = 2^5 + 2^4$, ed i rimanenti bit sono settati a 0, fino a 64.
\begin{center}
\includegraphics[scale= 0.5]{blocks7}
\end{center}

\subsection*{Attacco a SHA1 | SHAttered: first public collision}
On 23 February 2017, the CWI (Centrum Wiskunde \& Informatica) and Google announced the SHAttered attack, in which they generated two different PDF files with the same SHA-1 hash in roughly $2^{63.1}$ SHA-1 evaluations. This attack is about $100,000$ times faster than brute forcing a SHA-1 collision with a birthday attack, which was estimated to take $2^{80}$ SHA-1 evaluations. The attack required "the equivalent processing power of 6,500 years of single-CPU computations and 110 years of single-GPU computations"

\subsection*{Attacchi a funzioni hash}
\subsubsection*{Paradosso del compleanno}
Utilizzato per attaccare le funzioni hash e le firme digitali, il paradosso afferma che la probabilità che almeno due persone in un gruppo compiano gli anni lo stesso giorno è largamente superiore a quanto potrebbe dire l'intuito: infatti già in un gruppo di 23 persone la probabilità è circa 0,51 (51\%); con 30 persone essa supera 0,70 (70\%), con 50 persone tocca addirittura 0,97 (97\%). \\
Calcoliamo la probabilità secondo la quale 23 non compiano gli anni lo stesso giorno:
\begin{center}
$PND = (1 - 1/365) * (1-2/365)*$ $...$ $(1-22/365)$
\end{center}
Se ora calcoliamo \begin{center}
$1-PND$
\end{center}
Possiamo calcolare la probabilità di collisione.\\\\
Se PND è $0,493$ allora $1 - PND = 0,507$, ovvero c'è una probabilità del 50\% che due persone abbiamo lo stesso compleanno. In particolare la probabilità è 70\% per 30 persone, 89\% per 40 persone. La probabilità della collisione è approssimabile con \begin{center}
$1 - e^{-r^2/2N}$\\
ove $N =$ dimensione del campione $(365)$\\
e $r$ = dimensione scelta $(23, 30, 40)$
\end{center}
Un altro esempio applicabile è l'analisi delle targhe delle automobili, quant'è il numero di macchine che dobbiamo esaminare perché due abbiano la porzione delle cifre uguale?
\subsubsection*{Consideriamo con le funzioni hash}
N= è il nostro digest\\
r = numero di hash che dobbiamo calcolare per trovare una collisione\\
Questo tuttavia non ci permette di attaccare SHA1, in quanto gli hash che calcoliamo noi sono randomici. Per attaccare SHA1 effettuiamo un attacco simile a baby step giant step, calcolando
\begin{center}
$P = 1 - e^-\lambda$\\
$\lambda = r^2/N$
\end{center}

\section*{Firma digitale}
Consideriamo un contratto con messaggio $m$, effettuiamo:
\begin{center}
$m \rightarrow hash(m) \rightarrow$ $Firma RSA(hash(m))$
\end{center}
Il crittografo in questo caso deve difendersi sia dall'attacco a $hash(m)$ che da attacchi a $Firma RSA(hash(m))$. Andiamo quindi a firmare $l'hash(m)$ con RSA, consideriamo:
\begin{center}
Public: $(n,e)$\\
Private: $(p, q, d)$
\end{center}
E procedura di encryption $m^e = c$, e procedura di decryption $c^d = m$, andiamo ad applicare una variante. Consideriamo che $d$ è la chiave privata, posseduta solo dal proprietario.\\
Consideriamo procedura di encryption $m^d = c$ e procedura di decryption $c^e = m$.
\begin{center}
$m \rightarrow hash(m) = h$\\
$h^d \rightarrow$ firma
\end{center}
\subsection*{MSG recovery schemes RSA | Signatures with appendix El Gamal}
\emph{TBD to be completed}
\begin{center}
$El-Gamal: m, sig (h(m))$\\
\end{center}

\section*{Funzioni "zero-knowledge"}
It is common practice to label the two parties in a zero-knowledge proof as Peggy (the prover of the statement) and Victor (the verifier of the statement).\\
\begin{center}
\includegraphics[scale= 0.3]{0k}
\end{center}
In this story, Peggy has uncovered the secret word used to open a magic door in a cave. The cave is shaped like a ring, with the entrance on one side and the magic door blocking the opposite side. Victor wants to know whether Peggy knows the secret word; but Peggy, being a very private person, does not want to reveal her knowledge (the secret word) to Victor or to reveal the fact of her knowledge to the world in general.\\

They label the left and right paths from the entrance A and B. First, Victor waits outside the cave as Peggy goes in. Peggy takes either path A or B; Victor is not allowed to see which path she takes. Then, Victor enters the cave and shouts the name of the path he wants her to use to return, either A or B, chosen at random. Providing she really does know the magic word, this is easy: she opens the door, if necessary, and returns along the desired path.\\
\begin{center}
\includegraphics[scale= 0.3]{1k}
\end{center}

However, suppose she did not know the word. Then, she would only be able to return by the named path if Victor were to give the name of the same path by which she had entered. Since Victor would choose A or B at random, she would have a 50\% chance of guessing correctly. If they were to repeat this trick many times, say 20 times in a row, her chance of successfully anticipating all of Victor's requests would become vanishingly small (1 in 220, or very roughly 1 in a million).\\
Thus, if Peggy repeatedly appears at the exit Victor names, he can conclude that it is extremely probable that Peggy does, in fact, know the secret word.

\section*{Block-chaining}
\emph{$https://www.finriskalert.it/wp-content/uploads/visconti.pdf$}

\subsection*{Merkle-Tree}
Consideriamo una serie di transazioni, da 1 a 8, calcoliamo i loro hash, e li raggruppiamo a 2 a 2.
\begin{center}
\includegraphics[scale= 0.3]{2k}
\end{center}
I dati dei due puntatori hash vengono combinati, e utilizzati per calcolare un nuovo puntatore hash, interando progressivamente arriviamo prima o poi a una radice.
\begin{center}
\includegraphics[scale= 0.3]{3k}
\end{center}
Questo albero è chiamato un Merkle tree. Il Merkle Tree permette di verificare una potenziale manomissione, se per esempio un attaccante modifica una transazione, o un nodo intermedio, il valore della radice cambia.
\begin{center}
\includegraphics[scale= 0.3]{4k}
\end{center}
Un'altra proprietà del Merkel Tree è che ci permette di verificare l'appartenenza. Se vogliamo per esempio verificare pubblicamente che una transazione sia presente all'interno di un albero, conoscendo solo la radice, mostriamo i nodi dalla radice alla transazione.
\begin{center}
\includegraphics[scale= 0.3]{5k}
\end{center}
Questo ci permette di mostrare l'appartenenza all'albero, senza mostrare il valore della transazione.
Per effettivamente mostrare la proprietà di una transazione viene utilizzata la firma digitale.

\section*{Protocolli}

\section*{Curve elittiche}

\end{document}  